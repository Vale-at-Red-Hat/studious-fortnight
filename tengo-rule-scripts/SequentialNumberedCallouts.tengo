/*
    Tengo Language
    Checks that callouts outside the listing block are sequential
    $ tengo SequentialNumberedCallouts.tengo <asciidoc_file_to_validate>
*/

fmt := import("fmt")
os := import("os")
text := import("text")

input := os.args()
scope := os.read_file(input[2])
matches := []

// clean out multi-line comments
scope = text.re_replace("(?s) *(\n////.*?////\n)", scope, "")
//add a newline, it might be missing
scope += "\n"

prev_num := 0
callout_regex := "^<(\\d+)>"
listingblock_delim_regex := "^-{4,}$"
ifdef_regex := "^ifdef::"
ifndef_regex := "^ifndef::"
endif_regex := "^endif::"

in_conditional := false

for line in text.split(scope, "\n") {
  // trim trailing whitespace
  line = text.trim_space(line)

  // check if we're entering a conditional block
  if text.re_match(ifdef_regex, line) or text.re_match(ifndef_regex, line) {
    in_conditional := true
  }

  // check if we're exiting a conditional block
  if text.re_match(endif_regex, line) {
    in_conditional := false
  }

  //reset count if we hit a listing block delimiter
  if text.re_match(listingblock_delim_regex, line) {
    prev_num = 0
  }

  if not in_conditional and text.re_match(callout_regex, line) {
    callout := text.re_find("<(\\d+)>", line)
    for key, value in callout {
      //trim angle brackets from string
      trimmed := callout[key][0]["text"]
      trimmed = text.trim_prefix(trimmed, "<")
      trimmed = text.trim_suffix(trimmed, ">")
      //cast string > int
      num := text.atoi(trimmed)
      //start counting
      if num != prev_num+1 {
        start := text.index(scope, line)
        matches = append(matches, {begin: start, end: start + len(line)})
      }
      prev_num = num
    }
  }
}

if len(matches) == 0 {
  fmt.println("Callouts are sequential")
} else {
  fmt.println(matches)
}
